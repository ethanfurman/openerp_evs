#!/usr/bin/env python2.7
from __future__ import print_function

from antipathy import Path
from contextlib2 import ExitStack
from itertools import groupby
from pandaemonium import PidLockFile, LockError, AlreadyLocked
from scription import *
from signal import SIGKILL
from socket import getfqdn
from syslog import openlog, syslog, closelog, LOG_PID, LOG_INFO, LOG_CRON
from textwrap import dedent, wrap
from time import time
import errno
import gzip
import logging
import logging.handlers
import os
import random
import re
import traceback as tb
import sys

try:
    execfile('/etc/cronaide.conf')
except:
    message = dedent("""\
            To: %%s
            From: cron_check <noreply@%s>
            Subject: %%s

            %%s""" % (getfqdn() or 'nowhere.invalid'))
    mail_server = 'localhost'
    notify_list = ['root@localhost']

class Formatter(logging.Formatter):
    def format(self, record):
        record.pid = os.getpid()
        return logging.Formatter.format(self, record)

# API

@Script(
        log=Spec('logging level to use', OPTION, abbrev=None, force_default='INFO', type=u.upper),
        log_file=Spec('file to log to', OPTION, abbrev=None, force_default='/var/log/cronaide.log'),
        )
def main(log, log_file):
    global logger
    if log:
        logger = logging.getLogger()
        logger.setLevel(getattr(logging, log))
        handler = logging.handlers.RotatingFileHandler(log_file, maxBytes=1073741824, backupCount=7)
        handler.setFormatter(Formatter('%(asctime)s %(pid)d %(name)s %(levelname)s: %(message)s'))
        logger.addHandler(handler)
    else:
        logger = lambda *a, **kw: 0


@Command(
        email=('Who to send a test mail to.',),
        server=('Server to use', OPTION),
        )
def test_mail(email, server=mail_server):
    "send a test message to EMAIL via SERVER"
    msg = message % (email, 'test mail', 'hope you got this! :)')
    mail(mail_server, 25, msg)


@Command()
def self_test():
    print('checking /etc/cronaide.conf...', verbose=0)
    if os.path.exists('/etc/cronaide.conf'):
        print('  exists...', verbose=0)
        execfile('/etc/cronaide.conf')
        print('  parsed...', verbose=0)
        if message.count('%%s'):
            print('  %%s found (probably bad)', verbose=0)
        if message.count('%s') != 3:
            print('  %%s count is %d (should be 3: To, Subject, and Body)' % message.count('%s'), verbose=0)
        print('  message\n ', '-'*25, '\n ', '\n  '.join(message.split('\n')), '\n ', '-'*25, verbose=0)
        print('  mail server:', mail_server, verbose=0)
        print('  notify list:', ', '.join(notify_list), verbose=0)
    else:
        if message.count('%%s'):
            print('  %%s found (probably bad)', verbose=0)
        if message.count('%s') != 3:
            print('  %%s count is %d (should be 3: To, Subject, and Body)' % message.count('%s'), verbose=0)
        print('  does not exist, using defaults:', verbose=0)
        print('  message\n ', '-'*25, '\n ', '\n  '.join(message.split('\n')), '\n ', '-'*25, verbose=0)
        print('  mail server:', mail_server, verbose=0)
        print('  notify list:', ', '.join(notify_list), verbose=0)


@Command(
        email=Spec('Who to send job output to.', MULTI, force_default=notify_list),
        job_timeout=Spec('allowed time for job OR time to wait for lock (in seconds)', OPTION, force_default=3600),
        capture=('Send all output to EMAIL', FLAG, ),
        heartbeat=('Send notification of successful job run.', FLAG, ),
        passthrough=('Send STDOUT and STDERR streams to cron.', FLAG, ),
        check_stdout=Spec('check for "ERROR" in stdout stream', FLAG, abbrev=None, force_default=True),
        lock=Spec(
            'do LOCK if previous job still running',
            OPTION, force_default='wait', choices=['wait', 'kill'],
            ),
        lock_file=Spec(
            'use LOCK-FILE to prevent multiple concurrent runs',
            OPTION, abbrev=('f', 'lf'), default='/var/run/${job-name}.pid',
            ),
        lock_timeout=Spec(
            'amount of time to wait for previous job to finish',
            OPTION, abbrev='lt', force_default=-1,
            ),
        job=('job to run', REQUIRED, ),
        )
@Alias('cronaide')
def watch(email, job_timeout, capture, heartbeat, passthrough, check_stdout, lock_file, lock_timeout, lock, *job):
    """monitor JOB, sending results/status to EMAIL

    By default, a locking pid file is used with an immediate timeout, and
    the default action if the previous job is still running is to quit.
    (The lock filename is the name of the first command.)

    If the LOCK-* options are not specified, or LOCK_ACTION is quit, TIMEOUT is
    how long JOB is allowed to run before killing it;
    """
    if not email and (capture or heartbeat):
        abort('if CAPTURE or HEARTBEAT is specified then EMAIL must also be specified')
    if lock_file or lock:
        logger.info('lock: %s', lock)
        if lock_file is None:
            lock_file = script_commands[script_command_name].__scription__['lock_file']._script_default
        lock_file = lock_file.replace('${job-name}', Path(job[0]).filename)
        logger.info('lock-file: %s', lock_file)
    ppid = os.getppid()
    openlog('AIDE', LOG_PID, LOG_CRON)
    failed = False
    start = time()
    with ExitStack() as exit:
        syslog(LOG_INFO, '[from %s] start: %s' % (ppid, ' '.join(sys.argv)))
        exit.callback(closelog)
        if lock_file:
            try:
                lock_file = get_lock(lock, lock_file, lock_timeout)
            except LockError:
                cls, exc, tb = sys.exc_info()
                logger.error('%s; aborting', exc.args[0])
                if email:
                    msg = message % (
                        ','.join(email),
                        'job failed:  %s' % job[0].split('/')[-1],
                        exc.args[0],
                        )
                    mail(mail_server, 25, msg)
                    syslog(LOG_INFO, '[from %s] failed; mail sent <%r>' % (ppid, exc.args[0]))
                    sys.exit(0)
                else:
                    syslog(LOG_INFO, '[from %s] failed <%r>' % (ppid, exc.args[0]))
                    sys.exit(-1, exc.args[0])
            else:
                exit.push(lock_file)
                logger.info('lock obtained for PID: %d', lock_file.read_pid())
        logger.info('running job: %s', ' '.join(job))
        result = Job(job)
        if lock_file:
            lock_file.seal(result.pid)
        try:
            result.communicate(timeout=job_timeout)
        except TimeoutError:
            pass
        finally:
            result.close()
        stop = time()
        elapsed = stop - start
        msg = None
        if (check_stdout and 'ERROR' in result.stdout) or result.returncode or result.stderr:
            body = [
                    'job:  %s' % ' '.join(job),
                    'return code: %s' % result.returncode,
                    ]
            if result.stdout:
                body.append('stdout\n======\n%s' % result.stdout)
            if result.stderr:
                body.append('stderr\n======\n%s' % result.stderr)
            if email:
                print('error encountered, sending mail')
                failed = True
                msg = message % (
                    ','.join(email),
                    'job failed:  %s' % job[0].split('/')[-1],
                    '\n\n'.join(body),
                    )
                mail(mail_server, 25, msg)
                syslog(LOG_INFO, '[from %s] failed; mail sent' % ppid)
            else:
                syslog(LOG_INFO, '[from %s] failed' % ppid)
                print('\n\n'.join(body), file=stderr)
                sys.exit(result.returncode or -1, 'job failed')
        else:
            if heartbeat:
                print('sending heartbeat')
                msg = message % (
                    ','.join(email),
                    'heartbeat: %s' % job[0].split('/')[-1],
                    'job: %s\nran in: approximately %d seconds' % (' '.join(job), elapsed),
                    )
                mail(mail_server, 25, msg)
            if capture and result.stdout:
                print('catch and release')
                msg = message % (
                    ','.join(email),
                    'job:  %s' % job[0].split('/')[-1],
                    '%s\n\ntime to run\n===========\napproximately %d seconds\n\nstdout\n======\n%s' %
                    (' '.join(job), elapsed, result.stdout),
                    )
                mail(mail_server, 25, msg)
            if msg:
                syslog(LOG_INFO, '[from %s] succeeded; mail sent' % ppid)
            else:
                syslog(LOG_INFO, '[from %s] succeeded' % ppid)
        if passthrough or (failed and not email):
            print('relaying job output')
            if result.stdout:
                print(result.stdout, verbose=0, end='')
            if result.stderr:
                print(result.stderr, end='', file=sys.stderr)
            sys.exit(result.returncode)
    sys.exit(0)


@Command()
def check_cron():
    "search crontab for cronaide entries that have been commented out"
    openlog('AIDE', LOG_PID, LOG_CRON)
    ppid = os.getppid()
    syslog(LOG_INFO, '[from %s] start: %s' % (ppid, ' '.join(sys.argv)))
    msg = None
    with open('/etc/crontab') as crontab:
        warnings = []
        for line in crontab:
            if line.startswith('#:cron_check:'):
                _, email, prog = line.rsplit(':', 2)
                cron_check = next(crontab)
                if cron_check[0] == '#':
                    if email.strip():
                        addresses = email.split(',')
                    else:
                        addresses = notify_list
                    for addr in addresses:
                        warnings.append((addr, prog))
        warnings.sort()
        for email, progs in groupby(warnings, key=lambda ep: ep[0]):
            prog_names = []
            for _, prog in progs:
                prog_names.append(prog)
            msg = message % (email, 'disabled cron jobs', '\n%s'%'\n\t'.join(prog_names))
            mail(mail_server, 25, msg)
            syslog(LOG_INFO, '[from %s] succeeded; mail sent' % ppid)
    if msg is None:
        syslog(LOG_INFO, '[from %s] succeeded' % ppid)
    closelog()


@Command()
def check_syslog():
    """
    search crontab and syslog and verify that crontab entries of cronaide are running properly

    M: unable to find job in syslog
    E: job timed out and was killed
    S: job ran successfully
    F: job ran and failed
    """
    crontab = read('/etc/crontab')
    cron_jobs = {}
    commands = []
    for line in crontab.split('\n'):
        cronjob, command = is_cronaide(line)
        if command:
            commands.append(command)
            cron_jobs[command] = cronjob
            print('appended:', command, verbose=2)
    syslogs = Path('/var/log').glob('syslog*')
    syslogs.sort()
    aide = {}
    done = set()
    try:
        for sl in syslogs:
            print('checking %s...' % sl)
            sl = read(sl)
            sl = sl.split('\n')
            sl.reverse()
            for line in sl:
                match = re.search('AIDE\[(\d*)\]: \[from (\d*)\] (.*)', line)
                if match:
                    pid, ppid, msg = match.groups()
                    entry = aide.setdefault(ppid, {})
                    entry['child'] = pid
                    if msg.startswith('start'):
                        entry['start'] = msg
                    else:
                        entry['stop'] = msg
                    continue
                match = re.search('CRON\[(\d*)\]: \(\w*\) CMD \((.*)\)', line)
                if match:
                    ppid, msg = match.groups()
                    if msg.split()[0].endswith('cronaide'):
                        entry = aide.setdefault(ppid, {})
                        entry['command'] = command = ' '.join(msg.split())
                        try:
                            if command in done or command not in cron_jobs:
                                # ignore old versions and duplicates
                                del aide[ppid]
                            else:
                                print('removing:', command)
                                done.add(command)
                                commands.remove(entry['command'])
                        except ValueError:
                            print('msg:', msg, '\ndone:', done, '\nentry:', entry, '\ncommand list:', commands, file=stderr)
                            raise
                        if not commands:
                            raise BreakLoop
    except BreakLoop:
        pass
    succeeded = []
    failed = []
    errored = []
    missing = []
    if commands:
        for cmd in commands:
            missing.append(cmd)
    for ppid, entry in aide.items():
        if 'command' not in entry:
            # currently running, ignore
            continue
        cronjob = cron_jobs[entry['command']]
        if 'stop' in entry:
            msg = entry['stop']
            if msg.startswith('failed'):
                failed.append(cronjob)
            elif msg.startswith('succeeded'):
                succeeded.append(cronjob)
            else:
                print('unknown message for:\n  cronjob: %s\n  message: %s' % (cronjob, msg), file=stderr)
        else:
            errored.append(cronjob)
    for job in missing:
        print('\nM: ', '\n    '.join(wrap(job)), verbose=0)
    for job in errored:
        print('\nE: ', '\n    '.join(wrap(job)), verbose=0)
    for job in succeeded:
        print('\nS: ', '\n    '.join(wrap(job)), verbose=0)
    for job in failed:
        print('\nF: ', '\n    '.join(wrap(job)), verbose=0)


# supporting routines

def get_lock(lock, lock_file, timeout):
    lock_file = PidLockFile(lock_file)
    if lock == 'wait':
        # wait for lock, quit after timeout if unable to get lock
        try:
            lock_file.acquire(timeout=timeout)
        except AlreadyLocked:
            raise LockError('previous job(s) still running after timeout')
    elif lock == 'kill':
        lock_file.is_stale(timeout=1)
        orgpid = lock_file.stored_pid
        try:
            lock_file.acquire(timeout=timeout)
        except AlreadyLocked:
            actpid = lock_file.read_pid()
            if orgpid is not None and orgpid != actpid:
                raise LockError('previous job ended, another job took its place')
            else:
                try:
                    os.kill(actpid, SIGKILL)
                except OSError:
                    exc = sys.exc_info()[1]
                    if exc.errno != errno.ESRCH:
                        raise LockError('error killing previous job')
                try:
                    lock_file.acquire(timeout=random.randint(1, 5))
                except LockError:
                    raise LockError('unable to obtain lock')
    else:
        abort('unknown option for LOCK: %r' % lock)
    return lock_file

def read(filename):
    if filename.endswith('.gz'):
        open_file = gzip.open
    else:
        open_file = open
    with open_file(filename) as f:
        return f.read()

def is_cronaide(line):
    "determine if crontab line is calling cronaide"
    if line and line[0] != '#':
        segments = line.split()
        if len(segments) > 6:
            command = segments[6]
            if command.endswith('cronaide'):
                return ' '.join(segments), ' '.join(segments[6:])
    return False, False

class BreakLoop(Exception):
    pass

if __name__ == '__main__':
    try:
        Run()
    except Exception:
        body = tb.format_exc()
        print('mailing to:', ','.join(notify_list))
        mail(
            mail_server,
            25,
            message % (','.join(notify_list), ' '.join(sys.argv), body),
            )
        raise
