#!/usr/bin/env python2.7
from __future__ import print_function

from antipathy import Path
from itertools import groupby
from textwrap import dedent, wrap
from scription import *
from socket import getfqdn
from syslog import openlog, syslog, closelog, LOG_PID, LOG_INFO, LOG_CRON
from time import time
import gzip
import os
import re
import traceback as tb
import sys

try:
    execfile('/etc/cronaide.conf')
except:
    message = dedent("""\
            To: %%s
            From: cron_check <noreply@%s>
            Subject: %%s

            %%s""" % (getfqdn() or 'nowhere.invalid'))
    mail_server = 'localhost'
    notify_list = ['root@localhost']


@Command(
        email=('Who to send a test mail to.',),
        server=('Server to use', OPTION),
        )
def test_mail(email, server=mail_server):
    "send a test message to EMAIL via SERVER"
    msg = message % (email, 'test mail', 'hope you got this! :)')
    mail(mail_server, 25, msg)


@Command()
def self_test():
    print('checking /etc/cronaide.conf...', verbose=0)
    if os.path.exists('/etc/cronaide.conf'):
        print('  exists...', verbose=0)
        execfile('/etc/cronaide.conf')
        print('  parsed...', verbose=0)
        if message.count('%%s'):
            print('  %%s found (probably bad)', verbose=0)
        if message.count('%s') != 3:
            print('  %%s count is %d (should be 3: To, Subject, and Body)' % message.count('%s'), verbose=0)
        print('  message\n ', '-'*25, '\n ', '\n  '.join(message.split('\n')), '\n ', '-'*25, verbose=0)
        print('  mail server:', mail_server, verbose=0)
        print('  notify list:', ', '.join(notify_list), verbose=0)
    else:
        if message.count('%%s'):
            print('  %%s found (probably bad)', verbose=0)
        if message.count('%s') != 3:
            print('  %%s count is %d (should be 3: To, Subject, and Body)' % message.count('%s'), verbose=0)
        print('  does not exist, using defaults:', verbose=0)
        print('  message\n ', '-'*25, '\n ', '\n  '.join(message.split('\n')), '\n ', '-'*25, verbose=0)
        print('  mail server:', mail_server, verbose=0)
        print('  notify list:', ', '.join(notify_list), verbose=0)


@Command(
        email=Spec('Who to send job output to.', MULTI, default=notify_list),
        timeout=Spec('maximum amount of time to run in seconds', OPTION, default=3600),
        capture=('Send all output to <email>', FLAG, ),
        heartbeat=('Send notification of successful job run.', FLAG, ),
        passthrough=('Send STDOUT and STDERR streams to cron.', FLAG, ),
        job=('job to run', REQUIRED, ),
        )
@Alias('cronaide')
def watch(email, timeout, capture, heartbeat, passthrough, *job):
    "monitor a job, sending results/status to EMAIL"
    print('email addresses:', email)
    ppid = os.getppid()
    openlog('AIDE', LOG_PID, LOG_CRON)
    failed = False
    start = time()
    syslog(LOG_INFO, '[from %s] start: %s' % (ppid, ' '.join(sys.argv)))
    result = Execute(job, timeout=timeout)
    stop = time()
    elapsed = stop - start
    msg = None
    if 'ERROR' in result.stdout or result.returncode or result.stderr:
        print('error encountered, sending mail')
        failed = True
        msg = message % (
            ','.join(email),
            'job failed:  %s' % job[0].split('/')[-1],
            '%s\n\nreturn code: %s\n\nstdout\n======\n%s\n\nstderr\n======\n%s' %
            (' '.join(job), result.returncode, result.stdout, result.stderr),
            )
        mail(mail_server, 25, msg)
        syslog(LOG_INFO, '[from %s] failed; mail sent' % ppid)
    else:
        if heartbeat:
            print('sending heartbeat')
            msg = message % (
                ','.join(email),
                'heartbeat: %s' % job[0].split('/')[-1],
                'job: %s\nran in: approximately %d seconds' % (' '.join(job), elapsed),
                )
            mail(mail_server, 25, msg)
        if capture and result.stdout:
            print('catch and release')
            msg = message % (
                ','.join(email),
                'job:  %s' % job[0].split('/')[-1],
                '%s\n\ntime to run\n===========\napproximately %d seconds\n\nstdout\n======\n%s' %
                (' '.join(job), elapsed, result.stdout),
                )
            mail(mail_server, 25, msg)
        if msg:
            syslog(LOG_INFO, '[from %s] succeeded; mail sent' % ppid)
        else:
            syslog(LOG_INFO, '[from %s] succeeded' % ppid)
    if passthrough or (failed and not email):
        print('relaying job output')
        if result.stdout:
            print(result.stdout, verbose=0)
        if result.stderr:
            print(result.stderr, file=sys.stderr)
        sys.exit(result.returncode)
    sys.exit(0)


@Command()
def check_cron():
    "search crontab for cronaide entries that have been commented out"
    openlog('AIDE', LOG_PID, LOG_CRON)
    ppid = os.getppid()
    syslog(LOG_INFO, '[from %s] start: %s' % (ppid, ' '.join(sys.argv)))
    msg = None
    with open('/etc/crontab') as crontab:
        warnings = []
        for line in crontab:
            if line.startswith('#:cron_check:'):
                _, email, prog = line.rsplit(':', 2)
                cron_check = next(crontab)
                if cron_check[0] == '#':
                    if email.strip():
                        addresses = email.split(',')
                    else:
                        addresses = notify_list
                    for addr in addresses:
                        warnings.append((addr, prog))
        warnings.sort()
        for email, progs in groupby(warnings, key=lambda ep: ep[0]):
            prog_names = []
            for _, prog in progs:
                prog_names.append(prog)
            msg = message % (email, 'disabled cron jobs', '\n%s'%'\n\t'.join(prog_names))
            mail(mail_server, 25, msg)
            syslog(LOG_INFO, '[from %s] succeeded; mail sent' % ppid)
    if msg is None:
        syslog(LOG_INFO, '[from %s] succeeded' % ppid)


@Command()
def check_syslog():
    "search crontab and syslog and verify that crontab entries of cronaide are running properly"
    crontab = read('/etc/crontab')
    cron_jobs = {}
    commands = []
    for line in crontab.split('\n'):
        cronjob, command = is_cronaide(line)
        if command:
            commands.append(command)
            cron_jobs[command] = cronjob
            print('appended:', command, verbose=2)
    syslogs = Path('/var/log').glob('syslog*')
    syslogs.sort()
    aide = {}
    done = set()
    try:
        for sl in syslogs:
            print('checking %s...' % sl)
            sl = read(sl)
            sl = sl.split('\n')
            sl.reverse()
            for line in sl:
                match = re.search('AIDE\[(\d*)\]: \[from (\d*)\] (.*)', line)
                if match:
                    pid, ppid, msg = match.groups()
                    entry = aide.setdefault(ppid, {})
                    entry['child'] = pid
                    if msg.startswith('start'):
                        entry['start'] = msg
                    else:
                        entry['stop'] = msg
                    continue
                match = re.search('CRON\[(\d*)\]: \(\w*\) CMD \((.*)\)', line)
                if match:
                    ppid, msg = match.groups()
                    if msg.split()[0].endswith('cronaide'):
                        entry = aide.setdefault(ppid, {})
                        entry['command'] = command = ' '.join(msg.split())
                        try:
                            if command in done or command not in cron_jobs:
                                # ignore old versions and duplicates
                                del aide[ppid]
                            else:
                                print('removing:', command)
                                done.add(command)
                                commands.remove(entry['command'])
                        except ValueError:
                            print('msg:', msg, '\ndone:', done, '\nentry:', entry, '\ncommand list:', commands, file=stderr)
                            raise
                        if not commands:
                            raise BreakLoop
    except BreakLoop:
        pass
    succeeded = []
    failed = []
    errored = []
    missing = []
    if commands:
        for cmd in commands:
            missing.append(cmd)
    for ppid, entry in aide.items():
        if 'command' not in entry:
            # currently running, ignore
            continue
        cronjob = cron_jobs[entry['command']]
        if 'stop' in entry:
            msg = entry['stop']
            if msg.startswith('failed'):
                failed.append(cronjob)
            elif msg.startswith('succeeded'):
                succeeded.append(cronjob)
            else:
                print('unknown message for:\n  cronjob: %s\n  message: %s' % (cronjob, msg), file=stderr)
        else:
            errored.append(cronjob)
    for job in missing:
        print('\nM: ', '\n    '.join(wrap(job)), verbose=0)
    for job in errored:
        print('\nE: ', '\n    '.join(wrap(job)), verbose=0)
    for job in succeeded:
        print('\nS: ', '\n    '.join(wrap(job)), verbose=0)
    for job in failed:
        print('\nF: ', '\n    '.join(wrap(job)), verbose=0)


def read(filename):
    if filename.endswith('.gz'):
        open_file = gzip.open
    else:
        open_file = open
    with open_file(filename) as f:
        return f.read()

def is_cronaide(line):
    "determine if crontab line is calling cronaide"
    if line and line[0] != '#':
        segments = line.split()
        if len(segments) > 6:
            command = segments[6]
            if command.endswith('cronaide'):
                return ' '.join(segments), ' '.join(segments[6:])
    return False, False

class BreakLoop(Exception):
    pass

if __name__ == '__main__':
    try:
        Run()
    except Exception:
        body = tb.format_exc()
        print('mailing to:', ','.join(notify_list))
        mail(
            mail_server,
            25,
            message % (','.join(notify_list), ' '.join(sys.argv), body),
            )
        raise
