#!/usr/local/sbin/suid-python --virtualenv
"""\
Create, list, and restore OpenERP databases.
"""
from __future__ import print_function
from dbf import Date
from antipathy import Path
from scription import *
from tempfile import mkdtemp
from openerplib import get_connection, get_records
import os
import pwd
import re
import sys
import time

VIRTUAL_ENV = Path(os.environ['VIRTUAL_ENV'])
CONFIG_DIR = VIRTUAL_ENV / 'config'
pg_settings = IniFile(CONFIG_DIR / 'fnx.ini', section='postgres')
server_config = IniFile(CONFIG_DIR / 'server.conf', section='options', plain=True)
PGHOST = server_config.db_host
PGPORT = server_config.db_port
PGDATA = server_config.db_name
PGUSER = server_config.db_user
PGPSWD = server_config.db_password
PSQLCMD = '%(psql)s' % pg_settings
PGDUMPCMD = '%(pg_dump)s'
PGDUMPALLCMD = '%(pg_dumpall)s'
if PGHOST:
    print('PGHOST has a truthy value of %r' % PGHOST)
    PSQLCMD += ' -h %s' % PGHOST
    PGDUMPCMD += ' -h %s' % PGHOST
    PGDUMPALLCMD += ' -h %s' % PGHOST
if PGPORT:
    print('PGPORT has a truthy value of %r' % PGPORT)
    PSQLCMD += ' -p %s' % PGPORT
    PGDUMPCMD += ' -p %s' % PGPORT
    PGDUMPALLCMD += ' -p %s' % PGPORT
PGDUMPCMD += ' --file=%%(filename)s %%(db)s'
PGDUMPALLCMD += ' --file=%%(filename)s --globals-only'
DAILY_STORAGE = Path(pg_settings.daily)
MONTHLY_STORAGE = Path(pg_settings.monthly)
DAILY_LIMIT = pg_settings.daily_limit
MONTHLY_LIMIT = pg_settings.monthly_limit
TARARCHIVE = '%(tar)s --create --gzip --file %%(target_name)s %%(file_list)s' % pg_settings
TARDISPLAY = '%(tar)s --list --file %%(target)s' % pg_settings
TGZEXTRACT = '%(tar)s --file %%(archive)s --extract %%(target)s' % pg_settings
UNTAR = '%(tar)s -C %%(root_dir)s -xf %%(archive)s' % pg_settings
COMPRESS = '%(gzip)s --force --rsyncable %%(target_name)s' % pg_settings
oe_settings = IniFile(CONFIG_DIR / 'fnx.ini', section='openerp')
OEHOST = oe_settings.host
OEUSER = oe_settings.user
OEDATA = oe_settings.db
OEPSWD = oe_settings.pw

TODAY = Date.today()
POSTGRES_IDS = tuple(pwd.getpwnam('postgres')[2:4])
OPENERP_IDS = tuple(pwd.getpwnam('openerp')[2:4])
ACTUAL_IDS = os.getuid(), os.getgid()
TEMP = None
# PORT = None


@Script(
        rescue=('ignore checks', FLAG),
        )
def main(rescue):
    print('  main::0', verbose=2)
    print('  __file__ =', __file__, verbose=2)
    print('  virtual_env', VIRTUAL_ENV, verbose=2)
    #
    global START_DIR, TEMP, RESCUE
    #
    RESCUE = rescue
    #
    if not rescue:
        if not DAILY_STORAGE.exists():
            raise SystemExit('%s needs to be created, and owned by postgres' % DAILY_STORAGE)
        if not MONTHLY_STORAGE.exists():
            raise SystemExit('%s needs to be created, and owned by postgres' % MONTHLY_STORAGE)
    START_DIR = Path.getcwd()
    # _get_pg_port()
    print('  main::1', verbose=2)
    try:
        with user_ids(*POSTGRES_IDS):
            print('  main::2', verbose=2)
            TEMP = Path(mkdtemp(dir=unicode('/tmp'), suffix='_pgdbs'))
        script_command()
        print('finished')
    finally:
        print('  main::3', verbose=2)
        if TEMP:
            TEMP.rmtree()
        print('  main::4', verbose=2)
        START_DIR.chdir()


@Command(
        dbs=('database(s) to backup [default: all dbs]', MULTI),
        id=('extra info for extra backups (appears in compressed file name)', OPTION),
        dst=('where to put backup', OPTION, None, Path),
        files=('include files? [default: True if all dbs]', FLAG, None, Trivalent),
        )
def backup(dbs, id, dst, files):
    """
    backs up all postgres databases, roles, etc., or single databases
    """
    print('  backup::0', verbose=2)
    # get correct pg_dump and pg_dump_all
    _get_dump_cmds()
    print('  backup::1', verbose=2)
    everything = not bool(dbs)
    if files is Unknown:
        files = everything
    print('backing up everything?', everything)
    print('backing up files?', files)
    with user_ids(*POSTGRES_IDS):
        print('backup::', verbose=2)
        TEMP.chdir()
        if not dbs and not RESCUE and not dst:
            print('  backup::2', verbose=2)
            store = True
            storage = DAILY_STORAGE
            dbs = _get_dbs_from_postgres()
        else:
            print('  backup::3', verbose=2)
            store = False
            storage = TEMP
            if RESCUE and not dbs:
                dbs = _get_dbs_from_postgres()
        template = '%s.sql'
        failures = False
        # first, backup as many databases as we can
        print('backing up: ', end=' ')
        for db in dbs:
            print(db, end=' ')
            file = template % db
            if not _backup(db, file) and not db.startswith('template'):
                failures = True
        print()
        if everything:
            # if everything, get globals options...
            pg_dumpall = PGDUMPALLCMD % dict(filename=TEMP/'_roles_etc.sql')
            print('   roles, etc.', end='')
            result = Execute(pg_dumpall, pty=False)
            if result.returncode:
                print(' -- FAILED', file=stderr)
            else:
                print()
            if result.stdout:
                for line in result.stdout.strip().split('\n'):
                    print('   %s' % line)
            if result.returncode:
                print('       %s' % pg_dumpall, file=stderr)
                for line in result.stderr.split('\n'):
                    print('      %s' % line, file=stderr)
                print()
                failures = True

    # wait an extra few seconds to give tar file time to show up
    # (keep getting sporadic errors at Falcon)
    time.sleep(5)

    # postgres is backed up, revert to root privilege
    # then, combine them all into a single tar.gz file
    print('  backup::4', verbose=2)
    tgz_dbs_file = _tgz_dbs(TEMP, storage, id)
    if files:
        # now get files (must be after dbs or they would be included in the
        # dbs file
        tgz_bin_file = _tgz_files(storage, id)
    # finally, make a copy in monthly if today is the first day of the month
    # but only if store == True
    if store:
        if TODAY.day == 1:
            print('  backup::5', verbose=2)
            tgz_dbs_file.copy(MONTHLY_STORAGE)
            tgz_bin_file.copy(MONTHLY_STORAGE)
            print('  backup::6', verbose=2)
        _remove_excess(DAILY_STORAGE, DAILY_LIMIT)
        _remove_excess(MONTHLY_STORAGE, MONTHLY_LIMIT)
    else:
        print('  backup::7', verbose=2)
        tgz_dbs_file.chown(*ACTUAL_IDS)
        tgz_bin_file.chown(*ACTUAL_IDS)
        print('  backup::8', verbose=2)
        tgz_dbs_file.copy(dst or START_DIR)
        tgz_bin_file.copy(dst or START_DIR)
    if failures:
        raise SystemExit('not all databases backed up')


@Command()
def dbs():
    "list available databases in postgres"
    print('databases available: ', ', '.join(_get_dbs_from_postgres()), verbose=0)


@Command(
        date=Spec('date of archive file', OPTION, None, Date),
        dbs=Spec('names of dbs to extract [default: all]', MULTI, None),
        file=Spec('archive file to extract from', OPTION, None, Path),
        )
def extract(date, dbs, file):
    print('  extract::0', verbose=2)
    if date and file:
        abort('only one of DATE and FILE may be specified')
    if not (date or file):
        abort('must have one of DATE or FILE')
    if date:
        print('  extract::1', verbose=2)
        found = DAILY_STORAGE.glob('%s*' % date)
        if not found:
            print('  extract::2', verbose=2)
            found = MONTHLY_STORAGE.glob('%s*' % date)
            if not found:
                raise ValueError('no files found for %s' % date)
        if len(found) > 1:
            raise ValueError('should only have one match, but found %s' % ', '.join(found))
        [file] = found
    print(file)
    if not dbs:
        dbs = _list(file)
    extracted = []
    for db in dbs:
        print('   %s' % db)
        sql_file = _extract(db, file)
        extracted.append(sql_file)
    with user_ids(0, 0):
        print('  extract::3', verbose=2)
        for file in extracted:
            file.chown(*ACTUAL_IDS)


@Command(
        date=('date of archive to list', OPTION, 'd', Date),
        file=('archive file to list', OPTION, 'f', Path),
        daily=('show all daily backups', FLAG, None),
        monthly=('show all monthly backups', FLAG),
        )
def list(date, file, daily, monthly):
    """
    show all tables archived for DATE, or stored in FILE
    """
    print('  list::0', verbose=2)
    if sum(1 for p in [date, file, daily, monthly] if p) != 1:
        help('at least one (and only one) of DATE, FILE, DAILY, and MONTHLY may be specified')
    if daily:
        print('  list::1', verbose=2)
        for file in sorted(DAILY_STORAGE.glob('*')):
            echo(file)
    elif monthly:
        print('  list::2', verbose=2)
        for file in sorted(MONTHLY_STORAGE.glob('*')):
            echo(file)
    else:
        print('  list::3', verbose=2)
        if date:
            found = DAILY_STORAGE.glob('%s*' % date)
            if not found:
                print('  list::4', verbose=2)
                found = MONTHLY_STORAGE.glob('%s*' % date)
                if not found:
                    abort('no files found for %s' % date)
        print('  list::5', verbose=2)
        for file in found:
            echo(file)
            db_names = _list(file)
            for name in db_names:
                echo('   %s' % name)
            echo()
            print('  list::6', verbose=2)


@Command(
        date=('date of archive to restore from', OPTION, None, Date),
        db=('database in archive to restore', OPTION, None),
        file=('archive file to extract from / sql file to restore from', OPTION, None, Path),
        new_db=('restore as a new database [default: restore to same database]', OPTION, None),
        all_dbs=('restore all databases found in backup', FLAG, None),
        user_files=('restore user attachments, etc.', FLAG, None),
        config_files=Spec('restore configuration files', OPTION, None, choices=['missing', 'all']),
        )
def restore(db, date, file, new_db, all_dbs, user_files, config_files):
    print('  restore::0', verbose=2)
    if (db or all_dbs) and not _user_exists('openerp') and not RESCUE:
        abort('missing openerp user in postgresql, aborting restore [use --resuce to override]')
    if (user_files or config_files) and (db or all_dbs):
        abort('cannot restore database and files in one pass')
    if date and file:
        abort('only one of DATE and FILE may be specified')
    if not (date or file):
        help('must specify a date or a file')
    all_db_names = []
    all_sql_files = []
    tgz_file = sql_file = user_file = None
    if date:
        print('  restore::1', verbose=2)
        found = DAILY_STORAGE.glob('%s_pg*' % date)
        found_user = DAILY_STORAGE.glob('%s_files*' % date)
        print('found: ', found, verbose=3)
        print('found_user: ', found_user, verbose=3)
        if not found:
            print('  restore::2', verbose=2)
            found = MONTHLY_STORAGE.glob('%s_pg*' % date)
            found_user = MONTHLY_STORAGE.glob('%s_files*' % date)
            if not found:
                abort('no files found for %s' % date)
            if (user_files or config_files) and not found_user:
                abort('user/openerp config files not found for %s' % date)
        if len(found) > 1:
            abort('should only have one match, but found %s' % ', '.join(found))
        if len(found_user) > 1:
            abort('should anly have one match, but found %s' % ', '.join(found_user))
        [file] = found
        [user_file] = found_user
        if user_files:
            file = None
    if not (file or user_file):
        abort('no files found')
    if file:
        print('  restore::3', verbose=2)
        # if a file is specified copy it to TEMP
        file.copy(TEMP)
        file = TEMP/file.filename
        file.chown(*POSTGRES_IDS)
        if file.ext in ('.tar', '.gz', '.tgz'):
            tgz_file = file
            all_db_names = _list(tgz_file)
        else:
            sql_file = file
            if db is None:
                db = _db_name_from_file(sql_file)
        print('  restore::4', verbose=2)
        with user_ids(*POSTGRES_IDS):
            print('  restore::5', verbose=2)
            TEMP.chdir()
            print('  sql_file: %s\n  tgz_file: %s' % (sql_file, tgz_file), verbose=2)
            if tgz_file:
                print('  restore::6', verbose=2)
                # at this point, we have the archive file, and we have the
                # name(s) of the database to extract in db or all_db_names
                if db:
                    print('  restore::7', verbose=2)
                    sql_file = _extract(db, tgz_file)
                else:
                    print('  restore::8', verbose=2)
                    print('extracting sql files...')
                    for _db in all_db_names:
                        all_sql_files.append(_extract(_db, tgz_file))
            # we now have sql file(s) to restore from
            if all_dbs:
                # restore everything
                _restore_all_dbs(all_sql_files, all_db_names)
            elif db:
                # restore single database
                _restore_single_db(sql_file, db, new_db)
    if config_files:
        # UNTAR = '%(tar)s -C %%(root_dir)s -xf %%(archive)s' % pg_settings
        # restore attachments/etc. and/or config files
        _untar(archive=user_file, root_dir='/', target='tmp/oe_config.tar.gz')
        skip = config_files == 'missing'
        _untar(archive='/tmp/oe_config.tar.gz', root_dir=CONFIG_DIR, skip_old_files=skip)
    if user_files:
        _untar(archive=user_file, root_dir='/')

def _backup(db, filename):
    pg_dump = PGDUMPCMD % dict(filename=TEMP/filename, db=db)
    print('   %s' % db, end='')
    with user_ids(*POSTGRES_IDS):
        result = Execute(pg_dump, pty=False)
    if result.returncode:
        print(' -- FAILED', file=stderr)
    else:
        print()
    if result.stdout:
        for line in result.stdout.strip().split('\n'):
            print('   %s' % line)
    if result.returncode:
        print('       %s' % pg_dump, file=stderr)
        for line in result.stderr.split('\n'):
            print('      %s' % line, file=stderr)
        print()
    return not result.returncode

def _db_name_from_file(filename, datestr=None):
    print('  _db_name_from_file::0', verbose=2)
    print('  checking', filename, 'for datestr %r' % datestr, verbose=2)
    if datestr is None:
        # probably an sql filename
        print('  stripping date...')
        return re.sub('\d{4}-\d{1,2}-\d{1,2}_', '', filename.split('.')[0])
    if filename.startswith(datestr):
        print('  old-style filename')
        # old style with leading date and '_pg91.sql' trailer
        db_name = filename[11:].rsplit('_', 1)[0].strip()
    elif filename.endswith('.sql'):
        # new style with .sql trailer
        print('  new-style filename', verbose=2)
        db_name = filename[:-4]
    return db_name

def _extract(name, archive):
    print('_extract::0', verbose=2)
    date = archive.filename[:10]
    deprecated_name = '%s_%s_pg91.sql' % (date, name)
    name = name + '.sql'
    print('_extract::1', verbose=2)
    for target in (name, deprecated_name):
        print('_extract::2', verbose=2)
        tgz_cmd = TGZEXTRACT % dict(archive=archive, target=target)
        result = Execute(tgz_cmd, pty=False)
        if result.returncode == 0:
            print('  %s extracted' % target, verbose=2)
            break
    else:
        print('_extract::3', verbose=2)
        if result.stdout:
            for line in result.stdout.strip().split('\n'):
                print(line)
        print('return code:', result.returncode, file=stderr)
        for line in result.stderr.split('\n'):
            print(line, file=stderr)
        raise SystemExit(result.returncode)
    print('_extract::4', verbose=2)
    return Path(target)

def _get_dbs_from_postgres():
    result = _psql('--list --tuple')
    dbs = []
    for line in result.split('\n'):
        db = line.split('|', 1)[0].strip()
        if db and db != 'template0':
            # template0 is special, and cannot be accessed
            dbs.append(db)
    if not dbs:
        error('FAILED: %r' % result)
        raise SystemExit('no databases found!')
    return dbs

def _get_dbs_from_tar(tar_file):
    result = _psql('--list --tuple')
    dbs = []
    for line in result.split('\n'):
        db = line.split('|', 1)[0].strip()
        if db and db != 'template0':
            # template0 is special, and cannot be accessed
            dbs.append(db)
    if not dbs:
        error('FAILED: %r' % result)
        raise SystemExit('no databases found!')
    return dbs

def _get_dump_cmds():
    print('gdc::0', verbose=2)
    global PGDUMPCMD, PGDUMPALLCMD
    # get server version
    text = _psql("""-c "select current_setting('server_version_num')" --tuples-only""")
    print('gdc::1', verbose=2)
    version = 'v' + text.strip()[:-2]
    print('gdc::2', verbose=2)
    PGDUMPCMD %= pg_settings[version]
    print('gdc::3', verbose=2)
    PGDUMPALLCMD %= pg_settings[version]
    print('gdc::4', verbose=2)
    print('commands are:\n%r\n%r' % (PGDUMPCMD, PGDUMPALLCMD), verbose=3)

# def _get_pg_port():
#     global PORT, PSQLCMD
#     if PORT is not None:
#         return
#     if PGPORT:
#         PORT = '-p %d' % int(PGPORT)
#     else:
#         PORT = ''
#     PSQLCMD = (PSQLCMD % dict(port=PORT, user=PGUSER, host=PGHOST, database=PGDATA)).strip()

def _list(archive):
    print('  _list::1', verbose=2)
    print('checking archive', archive.filename)
    if 'pg91' in archive:
        tables = True
    else:
        tables = False
    datestr = archive.filename[:11]
    tgz_cmd = TARDISPLAY % dict(target=archive)
    result = Execute(tgz_cmd, pty=False)
    dbs = []
    if result.stdout:
        for line in result.stdout.strip().split('\n'):
            if tables:
                db_name = _db_name_from_file(line, datestr)
            else:
                db_name = line
            if db_name:
                dbs.append(db_name)
    if result.returncode:
        print('FAILED: %s' % tgz_cmd, file=stderr)
        for line in result.stderr.split('\n'):
            print('   %s' % line, file=stderr)
        raise SystemExit(result.returncode)
    print('  found: ', ', '.join(dbs))
    return dbs

def _psql(cmd):
    cmd = '%s %s' % (PSQLCMD, cmd)
    print(verbose=2)
    print(cmd, verbose=2)
    with user_ids(*POSTGRES_IDS):
        result = Execute(cmd, pty=False)
    if result.returncode:
        lines = []
        if result.returncode != -1:
            lines.append('FAILED: <%d> %s' % (result.returncode, cmd))
        for line in result.stderr.split('\n'):
            lines.append('   %s' % line)
        if result.returncode != -1:
            raise Exception('\n'.join(lines))
    return result.stdout

def _remove_excess(storage, limit):
    """
    keep LIMIT days worth of our backups
    """
    try:
        found_dbs = storage.glob('*_pg91.tar.gz')
        found_dbs.sort(reverse=True)
        found_bin = storage.glob('*_files.tar.gz')
        found_bin.sort(reverse=True)
        for target in found_dbs[limit:]:
            target.remove()
        for target in found_bin[limit:]:
            target.remove()
    except:
        print(sys.exc_info(), file=stderr)
        raise

def _restore_all_dbs(sql_files, dbs):
    print('  _restore_all::0', verbose=2)
    if len(sql_files) != len(dbs):
        print('sql files:\n  ', '\n   '.join(sql_files), file=stderr)
        print('db names:\n  ', '\n   '.join(dbs), file=stderr)
        abort('number of files vs number of databases differ')
    print('  _restore_all::1', verbose=2)
    for db in dbs:
        # some databases cannot be dropped
        if db in ('_roles_etc', 'postgres', 'template1'):
            continue
        print('dropping', db)
        _psql('-c "DROP DATABASE IF EXISTS %s;"' % db)
    log_file = Path('restore_all.log')
    print('  _restore_all::3', verbose=2)
    print('restoring globals... ', end='')
    _psql('--log-file %s --echo-all --file _roles_etc.sql' % log_file)
    print('success\nrestoring postgres... ', end='')
    postgres_file = sql_files[dbs.index('postgres')]
    if 'postgres' not in postgres_file:
        abort('\nlogic error: "postgres" table not in "%s"' % postgres_file)
    _psql('--log-file %s --echo-all --file %s postgres' % (log_file, postgres_file))
    print('sucess\nrestoring template1... ', end='')
    template1_file = sql_files[dbs.index('template1')]
    if 'template1' not in template1_file:
        abort('\nlogic error: "template1" table not in "%s"' % template1_file)
    _psql('--log-file %s --echo-all --file %s template1' % (log_file, template1_file))
    print('success')
    errors = []
    for db, sql_file in zip(dbs, sql_files):
        if db in ('_roles_etc', 'template1', 'postgres'):
            continue
        print('restoring %s... ' % db, end='')
        _psql('''-c "CREATE DATABASE %s TEMPLATE template1 ENCODING 'unicode';"''' % db)
        try:
            error = None
            print('  _restore_all::4', verbose=2)
            _psql(
                    '--log-file %(log)s --echo-all --file %(sql)s %(db_name)s'
                    % dict(sql=sql_file, db_name=db, log=log_file),
                    )
            print('  _restore_all::5', verbose=2)
            # TODO: find out if changing the owner is necessary
            _psql('-c "ALTER DATABASE %s OWNER TO openerp;"' % db)
        except Exception, exc:
            print('FAILED')
            errors.append(exc)
        else:
            print('success')
    with user_ids(0, 0):
        print('  _restore_all::6', verbose=2)
        dest_file = START_DIR/log_file.filename
        if dest_file.exists():
            print('  _restore_all::7', verbose=2)
            dest_file.remove()
        print('  _restore_all::8', verbose=2)
        log_file.chown(*ACTUAL_IDS)
        print('  _restore_all::9', verbose=2)
        log_file.move(dest_file)
    if errors:
        print('\nerrors', file=stderr)
        for error in errors:
            print('------', file=stderr)
            print(error, file=stderr)
        print('------', file=stderr)
        abort('errors encountered')
        # possibly examine the log file for errors here

def _restore_single_db(sql_file, db, new_db):
    if new_db is None:
        new_db = db
    if not new_db.startswith('test_'):
        print('  _restore_single::1', verbose=2)
        current_dbs = _get_dbs_from_postgres()
        if new_db in current_dbs:
            answer = get_response('\n%s already exists -- [r]ename or [o]verwrite?' % new_db)
            if answer == 'overwrite':
                if not get_response('\nthis cannot be undone -- are you sure?'):
                    raise SystemExit('database restore aborted')
                # drop...
                _psql('-c "DROP DATABASE %s;"' % new_db)
            elif answer == 'rename':
                print('\ncurrent databases:', verbose=0)
                for db in current_dbs:
                    print('  ', db, verbose=0)
                new_name = get_response(
                        '\nnew database name:',
                        validate=lambda name: name not in current_dbs,
                        type=lambda name: name,
                        retry='that name is also in use, please choose another',
                        )
                # rename...
                _psql('-c "ALTER DATABASE %s RENAME TO %s;"' % (new_db, new_name))
            else:
                raise Exception('unable to process response of %r' % answer)
    else:
        print('  _restore_single::2', verbose=2)
        # overwrite test_ databases
        _psql('-c "DROP DATABASE IF EXISTS %s;"' % new_db)
    # at this point we are good to restore...
    #
    # (re)create the new database
    log_file = Path(new_db+'.log')
    print('  _restore_single::3', verbose=2)
    _psql('''-c "CREATE DATABASE %s TEMPLATE template1 ENCODING 'unicode';"''' % new_db)
    try:
        error = None
        print('  _restore_single::4', verbose=2)
        _psql(
                '--log-file %(log)s --echo-all --file %(sql)s %(db_name)s'
                % dict(sql=sql_file, db_name=new_db, log=log_file),
                )
        print('  _restore_single::5', verbose=2)
        _psql('-c "ALTER DATABASE %s OWNER TO openerp;"' % new_db)
    except Exception, exc:
        error = exc
    with user_ids(0, 0):
        print('  _restore_single::6', verbose=2)
        dest_file = START_DIR/new_db+'.log'
        if dest_file.exists():
            print('  _restore_single::7', verbose=2)
            dest_file.remove()
        print('  _restore_single::8', verbose=2)
        log_file.chown(*ACTUAL_IDS)
        print('  _restore_single::9', verbose=2)
        log_file.move(dest_file)
    if error:
        raise error
    # possibly examine the log file for errors here

def _tgz_dbs(source_path, target_path, id=None):
    if id is None:
        target = target_path/'%s_pg91.tar.gz' % TODAY
    else:
        target = target_path/'%s_%s_pg91.tar.gz' % (TODAY, id)
    tgz_cmd = TARARCHIVE % dict(target_name=target, file_list=' '.join(source_path.listdir()))
    print('\narchiving . . .')
    result = Execute(tgz_cmd, cwd=source_path, pty=False, GZIP="--rsyncable")
    if result.stdout:
        for line in result.stdout.split('\n'):
            print('   %s' % line)
    if result.returncode:
        print('FAILED: %s' % tgz_cmd, file=stderr)
        for line in result.stderr.split('\n'):
            print('        %s' % line, file=stderr)
        raise SystemExit(result.returncode)
    print('\ncompressing . . .')
    return target

def _tgz_files(target_path, id=None):
    # static files/locations are in /var/openerp/
    # fnxfs.*
    # fnxfs/*
    # location of dynamic store is in openerp at
    #   ir.config_parameter:ir_attachment.location
    #
    # create config tar file in /tmp
    target = '/tmp/oe_config.tar.gz'
    CONFIG_DIR.chdir()
    tgz_cmd = TARARCHIVE % dict(target_name=target, file_list=' '.join(Path.glob('*')))
    print('\narchiving . . .')
    result = Execute(tgz_cmd, cwd=CONFIG_DIR, pty=False, GZIP="--rsyncable")
    if result.stdout:
        for line in result.stdout.split('\n'):
            print('   %s' % line)
    if result.returncode:
        print('FAILED: %s' % tgz_cmd, file=stderr)
        for line in result.stderr.split('\n'):
            print('        %s' % line, file=stderr)
        raise SystemExit(result.returncode)
    targets = Path('/var/openerp').glob('fnxfs.*')
    targets.append(Path('/var/openerp/fnxfs'))
    targets.append('/tmp/oe_config.tar.gz')
    conn = get_connection(hostname=OEHOST, database=OEDATA, login=OEUSER, password=OEPSWD)
    location = get_records(conn, 'ir.config_parameter', domain=[('key','=','ir_attachment.location')])
    if location:
        location = location[0].value
        if location.startswith('file://'):
            location = Path(location[7:])
            if location[0] not in '/\\':
                # add openerp directory to location
                location = VIRTUAL_ENV / 'openerp' / location
            targets.append(location)
    # file names collected, now generate tgz file name, and back them up
    if id is None:
        target = target_path/'%s_files.tar.gz' % TODAY
    else:
        target = target_path/'%s_%s_files.tar.gz' % (TODAY, id)
    tgz_cmd = TARARCHIVE % dict(target_name=target, file_list=' '.join(targets))
    print('\narchiving . . .')
    result = Execute(tgz_cmd, cwd='/', pty=False, GZIP="--rsyncable")
    if result.stdout:
        for line in result.stdout.split('\n'):
            print('   %s' % line)
    if result.returncode:
        print('FAILED: %s' % tgz_cmd, file=stderr)
        for line in result.stderr.split('\n'):
            print('        %s' % line, file=stderr)
        raise SystemExit(result.returncode)
    print('\ncompressing . . .')
    return target

def _untar(archive, root_dir, skip_old_files=False, target=None):
    untar_cmd = UNTAR % dict(root_dir=root_dir, archive=archive)
    if skip_old_files:
        untar_cmd += ' --skip-old-files'
    if target:
        untar_cmd += ' ' + target
    print('\nextracting . . .')
    result = Execute(untar_cmd, pty=False)
    if result.stdout:
        for line in result.stdout.split('\n'):
            print('   %s' % line)
    if result.returncode:
        print('FAILED: %s' % untar_cmd, file=stderr)
        for line in result.stderr.split('\n'):
            print('        %s' % line, file=stderr)
        raise SystemExit(result.returncode)

def _user_exists(user):
    output = _psql('-c "select rolname from pg_authid;"').split('\n')
    result = False
    for i, line in enumerate(output[2:], start=1):
        print(i, line)
        if line.strip() == user:
            result = True
    return result

Main()
