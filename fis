#!/usr/bin/python
from __future__ import print_function, unicode_literals

from collections import defaultdict
from itertools import cycle
from scription import *
from VSS.BBxXlate import fisData as fd
from VSS.BBxXlate.bbxfile import TableError
from antipathy import Path
import dbf
import random
import re
import sys

SOURCE = Path('/var/fis/production/')
ARCHIVE = Path('/var/openerp/archive/production/')
ERRORS = Path('/var/openerp/archive/production/error')


@Command(
        start=Spec('where to start checking', OPTION),
        )
def integrity_check(start=1):
    "check tables for key/record mismatches"
    i = start - 1
    while 'checking more tables':
        if i > 400:
            break
        i += 1
        try:
            table = fd.fisData(i)
        except TableError:
            cls, exc, tb = sys.exc_info()
            # import traceback
            # traceback.print_tb(tb)
            error('%10s  [%3d]:  %s' % (exc.filename, i, exc.__class__.__name__))
        except KeyError:
            pass
        else:
            if table.corrupted:
                error('%10s  [%3d]: %7d records,  %4d corrupted' % (table.filename, i, len(table), table.corrupted))
            else:
                print('%10s  [%3d]: %7d records' % (table.filename, i, len(table)))


@Command(
        filenum=Spec('file abbreviation or number to operate on', default='all', type=unicode.upper),
        which=Spec('which field to display', default='all', type=unicode.upper),
        )
def field_check(filenum, which):
    """
    Checks numeric fields for bad values.
    """
    if filenum != 'all':
        if filenum.isdigit():
            filenum = int(filenum)
        files = [filenum]
    else:
        files = [k for k in fd.tables if isinstance(k, (int, long))]
    for filenum in files:
        print('file: %s' % (filenum,), end=' ', verbose=0)
        try:
            table = fd.fisData(filenum)
        except TableError, exc:
            print('<%s>' % exc.__doc__, verbose=0)
            continue
        print(table.datamap)
        if which != 'all':
            fields = [which]
        else:
            fields = [f for f in table.datamap if '$' not in f]
        print('(%d records, %d numeric fields)' % (len(table), len(fields)), end='  ', verbose=0)
        ints = floats = 0
        bad_values = defaultdict(lambda: defaultdict(int))
        for record in table.values():
            for field in fields:
                val = record[field]
                try:
                    int(val)
                    ints += 1
                except ValueError:
                    try:
                        float(val)
                        floats += 1
                    except ValueError:
                        bad_values[field][val] += 1
        print('-- int: %s  --  float: %s' % (ints, floats), verbose=0)
        if bad_values:
            for field, values in bad_values.items():
                print('     %s: %s' % (field, ', '.join(repr(v) for v in values.items())), verbose=0)
        table.release()


@Command(
        table=Spec('FIS table to query', type=int),
        code=Spec('code to search for', ),
        fields=Spec('specific fields to display [default: all]', MULTI, type=int),
        )
def query(table, code, fields):
    key = table_keys.get(table)
    fis_table = fd.fisData(table, keymatch=key)
    for line in format_record(fis_table[code], fields):
        echo(line)


@Command(
        filenum=Spec('file abbreviation or number to operate on', ),
        # which=Spec('which record to display', choices=['random', 'last', int], default='random'),
        which=Spec('which record to display [random, last, <record_id>]', default='random'),
        )
def record(filenum, which):
    if filenum.isdigit():
        filenum = int(filenum)
    table = fd.fisData(filenum)
    print('using file', table.filename)
    if which == 'last':
        record = table.values()[-1]
    elif which == 'random':
        record = random.choice(table.values())
    else:
        record = table[which]
    print(record.rec)
    for line in format_record(record):
        echo(line)


@Command(
        filenum=Spec('file abbreviation or number to operate on', ),
        subset=Spec('subset template to match many records to', ),
        code=Spec('code to match with template', force_default='', type=lambda s: s and tuple(s.split(',') or s)),
        fields=Spec('specific fields to display [default: all, counting starts with 0]', MULTI, type=int),
        dbf_name=Spec('dbf to create with data', OPTION),
        )
def records(filenum, subset, code, fields, dbf_name):
    if filenum.isdigit():
        filenum = int(filenum)
    fis_table = fd.fisData(filenum, subset=subset)
    print('using file', fis_table.filename)
    records = [v for k, v in fis_table.get_subset(code)]
    used_fields = []
    if records:
        # get field defs now, may be needed for dbf creation
        record = records[0]
        print('widths:', record._widths, verbose=2)
        max_data_width = record._width
        max_spec_width = 0
        field_widths = []
        dbf_types = []
        dbf_names = []
        fis_fields = record.fieldlist
        for i, row in enumerate(fis_fields):
            if not fields or i in fields:
                name, spec = row[1:4:2]
                if not name.strip() or name.strip().lower() == '(open)':
                    continue
                max_spec_width = max(max_spec_width, len(spec.strip()))
                width = fis_table.field_widths[i]
                field_widths.append(width)
                field_name = convert_name(name, 10)
                if field_name in dbf_names:
                    print('duplicate name:', field_name, verbose=2)
                    prior = dbf_names.index(field_name)
                    print('  found at:', prior, verbose=2)
                    alt_name = convert_name(name, 9)
                    dbf_names[prior] = alt_name
                    dbf_types[prior] = dbf_types[prior].replace(field_name, alt_name)
                    print('  reset to:', dbf_names[prior], verbose=2)
                    print('  and:     ', dbf_types[prior], verbose=2)
                    field_name = alt_name + '2'
                dbf_names.append(field_name)
                name = convert_name(name)
                if '$' in spec:
                    dbf_types.append('%s C(%d)' % (field_name, width))
                    used_fields.append((i, str))
                else:
                    dbf_types.append('%s N(17,5)' % field_name)
                    used_fields.append((i, float))
        if dbf_name:
            print('dbf fields:\n  ', '\n   '.join(dbf_types))
            table = dbf.Table(dbf_name, dbf_types).open()
    try:
        fields = [t[0] for t in used_fields]
        for record in records:
            field_data = []
            for i, row in enumerate(fis_fields):
                lines = []
                if not fields or i in fields:
                    comment, spec = row[1:4:2]
                    data = record[row[3]]
                    field_data.append(data)
                    if '$' in row[3]:
                        lines.append('%5d | %*s | %*s | %s' % (i+1, -max_spec_width, spec, -max_data_width, data, comment))
                    else:
                        lines.append('%5d | %*s | %*s | %s' % (i+1, -max_spec_width, spec, max_data_width, data, comment))
                if not dbf_name and lines:
                    echo('\n'.join(lines))
            if dbf_name:
                data = []
                for i, item in enumerate(used_fields):
                    cnv = item[1]
                    data.append(cnv(field_data[i]))
                print('field data:', data, verbose=2)
                table.append(tuple(data))
            if not dbf_name:
                echo()
    except Exception:
        import traceback
        traceback.print_exc()
    finally:
        if dbf_name:
            table.close()


@Command(
        filenum=Spec('file abbreviation or number to display', ),
        output=Spec('output type', choices=['dump','enum'], default='dump'),
        )
def schema(filenum, output):
    if filenum.isdigit():
        filenum = int(filenum)
    table = fd.tables[filenum]
    if output == 'dump':
        max_width = 0
        for field in table['fields']:
            max_width = max(max_width, len(field[1]))
        max_width += 10
        print(table['name'], table['desc'], table['filenum'], verbose=0)
        dotted = True
        field_num = 0
        last_field = None
        for i, field in enumerate(table['fields']):
            if not i % 3:
                dotted = not dotted
            name = '  ' + field[1]
            spec = field[3]
            current_field = spec.split('(')[0]
            if current_field != last_field or current_field.lower() == 'i':
                field_num += 1
                last_field = current_field
                display_field_num = '%2d' % field_num
            if dotted:
                name += '.' * (max_width - len(name))
            else:
                name += ' ' * (max_width - len(name))
            print('%3d  %s' % (i+1, display_field_num), name, spec, verbose=0)
            display_field_num = '  '
    elif output == 'enum':
        print('class F%d(str, Enum):' % table['filenum'], verbose=0)
        print('    """', verbose=0)
        print('    %s - %s' % (table['name'], table['desc'].strip('-')), verbose=0)
        print('    """', verbose=0)
        lines = []
        for field in table['fields']:
            name, spec = field[1:4:2]
            comment = name
            name = convert_name(name)
            lines.append((name, spec, comment))
        #calculate widths
        max_name = max([len(n) for n, s, c in lines])
        max_spec = max([len(s) for n, s, c in lines]) + 2
        for name, spec, comment in lines:
            if name:
                print('    %-*s = %-*r     # %s' % (max_name, name, max_spec, spec, comment), verbose=0)
            else:
                print(' ' * (max_name + max_spec + 11), '# %s %s' % (comment, spec), verbose=0)
    else:
        abort('unknown output type: %s' % output)


@Command()
def tables():
    "list FIS tables"
    keys = [k for k in fd.tables.keys() if isinstance(k, (int,long))]
    keys.sort()
    for k in keys:
        t = fd.tables[k]
        echo('%4d: %s%s' % (k, t['name'], t['desc']))


@Command(
        filenum=Spec('file abbreviation or number to operate on', ),
        subset=Spec('subset template to match many records to', ),
        code=Spec('code to match with template', force_default='', type=lambda s: s and tuple(s.split(',') or s)),
        fields=Spec('specific fields to display [default: all, counting starts with 0]', MULTI, type=int),
        )
def values(filenum, subset, code, fields):
    if not fields:
        abort('no FIELDS specified')
    # adjust for zero-based numbering
    fields = [i-1 for i in fields]
    if filenum.isdigit():
        filenum = int(filenum)
    fis_table = fd.fisData(filenum, subset=subset)
    table_spec = fd.tables[filenum]
    table_fields = []
    for i, row in enumerate(table_spec['fields']):
        if i not in fields:
            continue
        name, spec = row[1:4:2]
        table_fields.append((name, spec, set()))
    for rec in [v for k, v in fis_table.get_subset(code)]:
        for name, spec, values in table_fields:
            values.add(rec[spec])
    for name, spec, values in table_fields:
        print('%s:  ' % name, ', '.join([repr(v) for v in sorted(values)]), verbose=0)

# helpers

table_keys = {
    328: '10%s000010000',
    }

def format_record(record, fields=None):
    lines = []
    name = value = 0
    if not fields:
        fields = range(len(record.fieldlist))
    for i, row in enumerate(record.fieldlist):
        if i in fields:
            name = max(len(row[3]), name)
            value = max(len(str(record[row[3]])), value)
    for i, row in enumerate(record.fieldlist):
        if i in fields:
            if '$' in row[3]:
                lines.append('%5d | %*s | %*s | %s' % (i+1, -name, row[3], -value, record[row[3]], row[1]))
            else:
                lines.append('%5d | %*s | %*s | %s' % (i+1, -name, row[3], value, record[row[3]], row[1]))
    return lines

def convert_name(name, max_len=50):
    name = name.lower()
    if '(' in name:
        name = name.split('(')[0]
    name = name.replace('.', '')
    for text in (' code', ' codes'):
        if name.endswith(text):
            name = name[:-len(text)+1] + 'id' + ('', 's')[text[-1] == 's']
            break
    pieces = name.split()
    if pieces and pieces[0].isdigit() and pieces[1:2] == ['spaces']:
        pieces = pieces[2:]
    for i, p in enumerate(pieces):
        if len(p) == 3 and '/' in p:
            pieces[i] = p[0] + p[2]
    name = ' '.join(pieces)
    if name.startswith(('key type', 'key group')):
        name = 'key type'
    member = []
    # name substitution
    for i, piece in enumerate(re.sub('\W+', ' ', name).split()):
        if i == 0 and piece[0].isdigit():
            piece = numbers.get(piece, piece)
        else:
            piece = common.get(piece, piece)
        member.append(piece)
    # shrink further as necessary
    def no_under(names):
        return ''.join(names)
    def pop_under(names):
        names.pop()
        return '_'.join(names)
    name = '_'.join(member)
    shrinker = cycle([no_under, pop_under])
    if len(name) > max_len:
        # first try uncommon abbr
        for i, m in enumerate(member):
            member[i] = uncommon.get(m, m)
        name = '_'.join(member)
    while len(name) > max_len:
        func = next(shrinker)
        name = func(member)
    return name

numbers = {
    '0':    'zero',
    '1':    'one',
    '2':    'two',
    '3':    'three',
    '4':    'four',
    '5':    'five',
    '6':    'six',
    '7':    'seven',
    '8':    'eight',
    '9':    'nine',
    '10':   'ten',
    '1st':  'first',
    '2nd':  'second',
    '3rd':  'third',
    '4th':  'fourth',
    '5th':  'fifth',
    '6th':  'sixth',
    '7th':  'seventh',
    '8th':  'eighth',
    '9th':  'ninth',
    '10th': 'tenth',
    }

common = {
    'account':      'acct',
    'adjustment':   'adj',
    'allowance':    'allwnc',
    'amount':       'amt',
    'authority':    'auth',
    'center':       'ctr',
    'centering':    'ctr',
    'check':        'chk',
    'credit':       'cr',
    'credits':      'crs',
    'customer':     'cust',
    'debit':        'dr',
    'debits':       'drs',
    'department':   'dept',
    'description':  'desc',
    'discount':     'disc',
    'ingredient':   'ingr',
    'length':       'len',
    'invoice':      'inv',
    'number':       'no',
    'numbers':      'nos',
    'payment':      'pymt',
    'product':      'prod',
    'production':   'prod',
    'position':     'pos',
    'quantity':     'qty',
    'revision':     'rev',
    'sequence':     'seq',
    'string':       'str',
    'transaction':  'trans',
    }

uncommon = {
    'adjust':       'adj',
    'company':      'comp',
    'other':        'oth',
    'total':        'ttl',
    }

Main()
